#!/usr/bin/env python3
"""
Joern MCP Server - Connects to Neo4j database to provide RAG functionality for Joern code analysis graphs.

This server uses FastMCP to expose tools that retrieve and process information from
a Neo4j database populated with Joern's Code Property Graph (CPG) data.
"""

from __future__ import annotations

import os
import json
import logging
from dataclasses import dataclass
from typing import List, Dict, Any, Optional, Union
from pathlib import Path
from dotenv import load_dotenv

from mcp.server.fastmcp import FastMCP
from neo4j import AsyncGraphDatabase, AsyncSession
from pydantic_ai import Agent, RunContext, ModelRetry
from pydantic_ai.models.anthropic import AnthropicModel
from anthropic import AsyncAnthropic

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s"
)
logger = logging.getLogger(__name__)

# Load environment variables
load_dotenv()

# Neo4j connection settings
NEO4J_URI = os.getenv("NEO4J_URI", "bolt://localhost:7687")
NEO4J_USER = os.getenv("NEO4J_USER", "neo4j")
NEO4J_PASSWORD = os.getenv("NEO4J_PASSWORD", "password")
NEO4J_DATABASE = os.getenv("NEO4J_DATABASE", "neo4j")

# LLM settings
LLM_MODEL = os.getenv('LLM_MODEL', 'claude-3-sonnet-20240229')
ANTHROPIC_API_KEY = os.getenv("ANTHROPIC_API_KEY")

# Configure Claude model
model = AnthropicModel(LLM_MODEL)

@dataclass
class JoernAgentDeps:
    """Dependencies for the Joern Agent."""
    anthropic_client: AsyncAnthropic
    neo4j_uri: str
    neo4j_user: str
    neo4j_password: str
    neo4j_database: str

# System prompt for the Joern agent
SYSTEM_PROMPT = """
You are an expert at code security analysis using Joern and Code Property Graphs (CPG).

You have access to a Neo4j database containing a code property graph generated by Joern. 
This graph represents source code with nodes for code constructs (functions, methods, variables)
and edges representing relationships between them (calls, contains, etc.).

Your job is to help users analyze code security using the graph data. You can:
1. Find specific code patterns in the graph
2. Identify potential security vulnerabilities
3. Trace dataflow and control flow through the code
4. Answer questions about code structure and dependencies

Always use the provided tools to query the graph database before answering questions.
Explain your findings clearly, citing the graph data you found.

When you don't find relevant information in the graph, be honest and say so.
"""

# Initialize the Joern agent
joern_agent = Agent(
    model,
    system_prompt=SYSTEM_PROMPT,
    deps_type=JoernAgentDeps,
    retries=2
)

async def get_embedding(text: str, anthropic_client: AsyncAnthropic) -> List[float]:
    """Get embedding vector from Claude."""
    try:
        response = await anthropic_client.embeddings.create(
            model="claude-3-sonnet-20240229",
            input=text,
            type="text"
        )
        return response.embeddings[0].values
    except Exception as e:
        logger.error(f"Error getting embedding: {e}")
        return [0] * 1024  # Return zero vector on error - Claude's embedding size is 1024

async def get_neo4j_session(ctx: RunContext[JoernAgentDeps]) -> AsyncSession:
    """Create and return a Neo4j database session."""
    driver = AsyncGraphDatabase.driver(
        ctx.deps.neo4j_uri,
        auth=(ctx.deps.neo4j_user, ctx.deps.neo4j_password)
    )
    return driver.session(database=ctx.deps.neo4j_database)

@joern_agent.tool
async def run_cypher_query(ctx: RunContext[JoernAgentDeps], query: str) -> str:
    """
    Execute a Cypher query against the Neo4j database and return the results.
    
    Args:
        ctx: The context including Neo4j connection details
        query: The Cypher query to execute
        
    Returns:
        A formatted string containing the query results
    """
    try:
        logger.info(f"Executing Cypher query: {query}")
        driver = AsyncGraphDatabase.driver(
            ctx.deps.neo4j_uri,
            auth=(ctx.deps.neo4j_user, ctx.deps.neo4j_password)
        )
        
        async with driver.session(database=ctx.deps.neo4j_database) as session:
            result = await session.run(query)
            records = await result.values()
            
            # Format the results
            if not records:
                return "No results found for the query."
            
            # Attempt to convert to JSON for better readability
            try:
                formatted_results = json.dumps(records, indent=2)
                return f"Query results:\n```json\n{formatted_results}\n```"
            except:
                # Fallback to simple string representation if JSON conversion fails
                return f"Query results:\n{records}"
    except Exception as e:
        logger.error(f"Error executing Cypher query: {e}")
        return f"Error executing Cypher query: {str(e)}"
    finally:
        await driver.close()

@joern_agent.tool
async def get_node_types(ctx: RunContext[JoernAgentDeps]) -> str:
    """
    Get all available node types in the Code Property Graph.
    
    Args:
        ctx: The context including Neo4j connection details
        
    Returns:
        A formatted string listing all node types in the graph
    """
    query = """
    MATCH (n)
    RETURN DISTINCT labels(n) AS NodeTypes, count(*) AS Count
    ORDER BY Count DESC
    """
    return await run_cypher_query(ctx, query)

@joern_agent.tool
async def get_edge_types(ctx: RunContext[JoernAgentDeps]) -> str:
    """
    Get all available relationship types in the Code Property Graph.
    
    Args:
        ctx: The context including Neo4j connection details
        
    Returns:
        A formatted string listing all relationship types in the graph
    """
    query = """
    MATCH ()-[r]->()
    RETURN DISTINCT type(r) AS RelationshipType, count(*) AS Count
    ORDER BY Count DESC
    """
    return await run_cypher_query(ctx, query)

@joern_agent.tool
async def find_functions(ctx: RunContext[JoernAgentDeps], pattern: Optional[str] = None) -> str:
    """
    Find functions in the codebase, optionally filtering by name pattern.
    
    Args:
        ctx: The context including Neo4j connection details
        pattern: Optional regex pattern to filter function names
        
    Returns:
        A formatted string listing matching functions
    """
    query = """
    MATCH (f:METHOD)
    WHERE f.NAME IS NOT NULL
    """
    
    if pattern:
        query += f" AND f.NAME =~ '(?i).*{pattern}.*'"
    
    query += """
    RETURN f.NAME AS FunctionName, f.FILENAME AS Filename, f.LINE_NUMBER AS LineNumber
    ORDER BY FunctionName
    LIMIT 20
    """
    
    return await run_cypher_query(ctx, query)

@joern_agent.tool
async def find_vulnerabilities(ctx: RunContext[JoernAgentDeps], vulnerability_type: Optional[str] = None) -> str:
    """
    Find potential security vulnerabilities in the code.
    
    Args:
        ctx: The context including Neo4j connection details
        vulnerability_type: Optional type of vulnerability to look for (e.g., "sql_injection", "buffer_overflow")
        
    Returns:
        A formatted string describing potential vulnerabilities found
    """
    # Define patterns for common vulnerabilities
    vulnerability_patterns = {
        "sql_injection": [
            "MATCH (call:CALL)-[:ARGUMENT]->(arg) WHERE call.NAME =~ '(?i).*(sql|query|exec).*' RETURN call.NAME, arg.CODE",
            "Find SQL injection vulnerabilities where user input might be used in SQL queries."
        ],
        "buffer_overflow": [
            "MATCH (call:CALL) WHERE call.NAME IN ['strcpy', 'strcat', 'sprintf', 'gets'] RETURN call.NAME, call.FILENAME, call.LINE_NUMBER",
            "Find unsafe C functions that can lead to buffer overflows."
        ],
        "command_injection": [
            "MATCH (call:CALL) WHERE call.NAME IN ['system', 'exec', 'popen', 'execve'] RETURN call.NAME, call.FILENAME, call.LINE_NUMBER",
            "Find command execution functions that could be vulnerable to injection."
        ],
        "path_traversal": [
            "MATCH (call:CALL)-[:ARGUMENT]->(arg) WHERE call.NAME =~ '(?i).*(open|read|file).*' RETURN call.NAME, arg.CODE",
            "Find potential path traversal vulnerabilities in file operations."
        ]
    }
    
    results = []
    
    if vulnerability_type and vulnerability_type in vulnerability_patterns:
        # Run specific vulnerability query
        query, description = vulnerability_patterns[vulnerability_type]
        result = await run_cypher_query(ctx, query)
        results.append(f"## {vulnerability_type.title()} Analysis\n{description}\n\n{result}")
    else:
        # Run all vulnerability queries
        for vuln_type, (query, description) in vulnerability_patterns.items():
            result = await run_cypher_query(ctx, query)
            results.append(f"## {vuln_type.title()} Analysis\n{description}\n\n{result}")
    
    return "\n\n".join(results)

@joern_agent.tool
async def analyze_function(ctx: RunContext[JoernAgentDeps], function_name: str) -> str:
    """
    Perform detailed analysis of a specific function.
    
    Args:
        ctx: The context including Neo4j connection details
        function_name: Name of the function to analyze
        
    Returns:
        A formatted string with detailed analysis of the function
    """
    # Query to get function details
    function_query = f"""
    MATCH (f:METHOD)
    WHERE f.NAME = '{function_name}'
    RETURN f.NAME AS Name, f.FILENAME AS Filename, f.LINE_NUMBER AS LineNumber, f.CODE AS Code
    LIMIT 1
    """
    function_result = await run_cypher_query(ctx, function_query)
    
    # Query to get function calls
    calls_query = f"""
    MATCH (f:METHOD)-[:CONTAINS]->(call:CALL)
    WHERE f.NAME = '{function_name}'
    RETURN call.NAME AS CalledFunction, count(*) AS CallCount
    ORDER BY CallCount DESC
    """
    calls_result = await run_cypher_query(ctx, calls_query)
    
    # Query to get data flow
    dataflow_query = f"""
    MATCH (f:METHOD)-[:CONTAINS]->(n)-[flow:FLOWS_TO]->(m)
    WHERE f.NAME = '{function_name}'
    RETURN n.CODE AS Source, m.CODE AS Target, flow.VARIABLE AS Variable
    LIMIT 20
    """
    dataflow_result = await run_cypher_query(ctx, dataflow_query)
    
    analysis = [
        f"# Analysis of function: {function_name}",
        "## Function Details",
        function_result,
        "## Function Calls",
        calls_result,
        "## Data Flow",
        dataflow_result
    ]
    
    return "\n\n".join(analysis)

@joern_agent.tool
async def trace_dataflow(ctx: RunContext[JoernAgentDeps], source_function: str, sink_function: Optional[str] = None) -> str:
    """
    Trace data flow paths from source to sink.
    
    Args:
        ctx: The context including Neo4j connection details
        source_function: Source function name (potential entry point)
        sink_function: Optional sink function name (potential vulnerability point)
        
    Returns:
        A formatted string describing data flow paths
    """
    if sink_function:
        # Trace from specific source to specific sink
        query = f"""
        MATCH path = (:METHOD {{NAME: '{source_function}'}})-[:CONTAINS]->()-[:FLOWS_TO*1..10]->()<-[:CONTAINS]-(:METHOD {{NAME: '{sink_function}'}})
        RETURN nodes(path) AS Path
        LIMIT 5
        """
    else:
        # Trace from source to any potential vulnerable function
        query = f"""
        MATCH path = (:METHOD {{NAME: '{source_function}'}})-[:CONTAINS]->()-[:FLOWS_TO*1..10]->()<-[:CONTAINS]-(sink:METHOD)
        WHERE sink.NAME IN ['exec', 'system', 'open', 'read', 'write', 'strcpy', 'memcpy']
        RETURN nodes(path) AS Path
        LIMIT 5
        """
    
    return await run_cypher_query(ctx, query)

@joern_agent.tool
async def search_code_patterns(ctx: RunContext[JoernAgentDeps], pattern: str) -> str:
    """
    Search for specific code patterns in the codebase.
    
    Args:
        ctx: The context including Neo4j connection details
        pattern: Code pattern to search for
        
    Returns:
        A formatted string listing matching code snippets
    """
    query = f"""
    MATCH (n)
    WHERE n.CODE IS NOT NULL AND n.CODE =~ '(?is).*{pattern}.*'
    RETURN n.CODE AS CodeSnippet, labels(n) AS NodeType, n.FILENAME AS Filename, n.LINE_NUMBER AS LineNumber
    LIMIT 20
    """
    
    return await run_cypher_query(ctx, query)

@joern_agent.tool
async def rag_query(ctx: RunContext[JoernAgentDeps], query: str) -> str:
    """
    Perform a RAG query using embeddings to find relevant code in the graph.
    
    Args:
        ctx: The context including Neo4j connection details and Claude client
        query: The query to find relevant code snippets
        
    Returns:
        A formatted string with relevant code snippets and their context
    """
    try:
        # Get embedding for the query
        query_embedding = await get_embedding(query, ctx.deps.anthropic_client)
        
        # We'll use a simple similarity search for now
        # In a real implementation, you might want to store embeddings in Neo4j and use vector similarity there
        
        # Get a sample of code snippets for comparison
        code_query = """
        MATCH (n)
        WHERE n.CODE IS NOT NULL
        RETURN n.CODE AS CodeSnippet, n.FILENAME AS Filename, n.LINE_NUMBER AS LineNumber
        LIMIT 100
        """
        
        driver = AsyncGraphDatabase.driver(
            ctx.deps.neo4j_uri,
            auth=(ctx.deps.neo4j_user, ctx.deps.neo4j_password)
        )
        
        relevant_snippets = []
        
        async with driver.session(database=ctx.deps.neo4j_database) as session:
            result = await session.run(code_query)
            records = await result.values()
            
            for record in records:
                code_snippet = record[0]
                filename = record[1] if len(record) > 1 else "Unknown"
                line_number = record[2] if len(record) > 2 else "Unknown"
                
                # Get embedding for this code snippet
                snippet_embedding = await get_embedding(code_snippet, ctx.deps.anthropic_client)
                
                # Calculate cosine similarity (simplified implementation)
                similarity = sum(a*b for a, b in zip(query_embedding, snippet_embedding))
                
                relevant_snippets.append({
                    "code": code_snippet,
                    "filename": filename,
                    "line_number": line_number,
                    "similarity": similarity
                })
        
        # Sort by similarity (descending)
        relevant_snippets.sort(key=lambda x: x["similarity"], reverse=True)
        
        # Return top 5 results
        top_results = relevant_snippets[:5]
        
        formatted_results = [
            "# Top Relevant Code Snippets",
            "Based on semantic similarity to your query, here are the most relevant code snippets:"
        ]
        
        for i, result in enumerate(top_results, 1):
            formatted_results.append(f"## Result {i} (Filename: {result['filename']}, Line: {result['line_number']})")
            formatted_results.append(f"```\n{result['code']}\n```")
        
        return "\n\n".join(formatted_results)
    except Exception as e:
        logger.error(f"Error in RAG query: {e}")
        return f"Error performing RAG query: {str(e)}"
    finally:
        await driver.close()

# Initialize FastMCP server with the Joern agent
mcp = FastMCP("joern_analyzer")

@mcp.tool()
async def run_query(query: str) -> str:
    """Execute a Cypher query against the Neo4j database containing the Code Property Graph."""
    ctx = RunContext(deps=JoernAgentDeps(
        anthropic_client=AsyncAnthropic(api_key=ANTHROPIC_API_KEY),
        neo4j_uri=NEO4J_URI,
        neo4j_user=NEO4J_USER,
        neo4j_password=NEO4J_PASSWORD,
        neo4j_database=NEO4J_DATABASE
    ))
    return await run_cypher_query(ctx, query)

@mcp.tool()
async def get_node_labels() -> str:
    """Get all available node labels/types in the Code Property Graph."""
    ctx = RunContext(deps=JoernAgentDeps(
        anthropic_client=AsyncAnthropic(api_key=ANTHROPIC_API_KEY),
        neo4j_uri=NEO4J_URI,
        neo4j_user=NEO4J_USER,
        neo4j_password=NEO4J_PASSWORD,
        neo4j_database=NEO4J_DATABASE
    ))
    return await get_node_types(ctx)

@mcp.tool()
async def get_relationship_types() -> str:
    """Get all available relationship types in the Code Property Graph."""
    ctx = RunContext(deps=JoernAgentDeps(
        anthropic_client=AsyncAnthropic(api_key=ANTHROPIC_API_KEY),
        neo4j_uri=NEO4J_URI,
        neo4j_user=NEO4J_USER,
        neo4j_password=NEO4J_PASSWORD,
        neo4j_database=NEO4J_DATABASE
    ))
    return await get_edge_types(ctx)

@mcp.tool()
async def find_code_functions(pattern: Optional[str] = None) -> str:
    """Find functions in the codebase, optionally filtering by name pattern."""
    ctx = RunContext(deps=JoernAgentDeps(
        anthropic_client=AsyncAnthropic(api_key=ANTHROPIC_API_KEY),
        neo4j_uri=NEO4J_URI,
        neo4j_user=NEO4J_USER,
        neo4j_password=NEO4J_PASSWORD,
        neo4j_database=NEO4J_DATABASE
    ))
    return await find_functions(ctx, pattern)

@mcp.tool()
async def find_security_vulnerabilities(vulnerability_type: Optional[str] = None) -> str:
    """Find potential security vulnerabilities in the code."""
    ctx = RunContext(deps=JoernAgentDeps(
        anthropic_client=AsyncAnthropic(api_key=ANTHROPIC_API_KEY),
        neo4j_uri=NEO4J_URI,
        neo4j_user=NEO4J_USER,
        neo4j_password=NEO4J_PASSWORD,
        neo4j_database=NEO4J_DATABASE
    ))
    return await find_vulnerabilities(ctx, vulnerability_type)

@mcp.tool()
async def analyze_code_function(function_name: str) -> str:
    """Perform detailed analysis of a specific function."""
    ctx = RunContext(deps=JoernAgentDeps(
        anthropic_client=AsyncAnthropic(api_key=ANTHROPIC_API_KEY),
        neo4j_uri=NEO4J_URI,
        neo4j_user=NEO4J_USER,
        neo4j_password=NEO4J_PASSWORD,
        neo4j_database=NEO4J_DATABASE
    ))
    return await analyze_function(ctx, function_name)

@mcp.tool()
async def trace_code_dataflow(source_function: str, sink_function: Optional[str] = None) -> str:
    """Trace data flow paths from source to sink."""
    ctx = RunContext(deps=JoernAgentDeps(
        anthropic_client=AsyncAnthropic(api_key=ANTHROPIC_API_KEY),
        neo4j_uri=NEO4J_URI,
        neo4j_user=NEO4J_USER,
        neo4j_password=NEO4J_PASSWORD,
        neo4j_database=NEO4J_DATABASE
    ))
    return await trace_dataflow(ctx, source_function, sink_function)

@mcp.tool()
async def search_for_code_patterns(pattern: str) -> str:
    """Search for specific code patterns in the codebase."""
    ctx = RunContext(deps=JoernAgentDeps(
        anthropic_client=AsyncAnthropic(api_key=ANTHROPIC_API_KEY),
        neo4j_uri=NEO4J_URI,
        neo4j_user=NEO4J_USER,
        neo4j_password=NEO4J_PASSWORD,
        neo4j_database=NEO4J_DATABASE
    ))
    return await search_code_patterns(ctx, pattern)

@mcp.tool()
async def rag_code_query(query: str) -> str:
    """Perform a RAG query to find relevant code in the graph."""
    ctx = RunContext(deps=JoernAgentDeps(
        anthropic_client=AsyncAnthropic(api_key=ANTHROPIC_API_KEY),
        neo4j_uri=NEO4J_URI,
        neo4j_user=NEO4J_USER,
        neo4j_password=NEO4J_PASSWORD,
        neo4j_database=NEO4J_DATABASE
    ))
    return await rag_query(ctx, query)

if __name__ == "__main__":
    # Initialize and run the server
    mcp.run(transport='stdio')
